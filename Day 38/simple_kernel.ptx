//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-33961263
// Cuda compilation tools, release 12.4, V12.4.99
// Based on NVVM 7.0.1
//

.version 8.4            // PTX version
.target sm_52           // Target GPU architecture (sm_52 = Maxwell)
.address_size 64        // Uses 64-bit addressing mode

// Kernel function definition: _Z3addPiS_S_i (mangled name of add(int*, int*, int*, int))
.visible .entry _Z3addPiS_S_i(
    .param .u64 _Z3addPiS_S_i_param_0,  // First parameter: pointer to array A
    .param .u64 _Z3addPiS_S_i_param_1,  // Second parameter: pointer to array B
    .param .u64 _Z3addPiS_S_i_param_2,  // Third parameter: pointer to array C (output)
    .param .u32 _Z3addPiS_S_i_param_3   // Fourth parameter: integer n (array size)
)
{
    .reg .pred  %p<2>;  // Predicate register (used for conditional execution)
    .reg .b32   %r<9>;  // General-purpose 32-bit registers
    .reg .b64   %rd<11>; // General-purpose 64-bit registers

    // Load kernel parameters into registers
    ld.param.u64  %rd1, [_Z3addPiS_S_i_param_0];  // Load address of A into %rd1
    ld.param.u64  %rd2, [_Z3addPiS_S_i_param_1];  // Load address of B into %rd2
    ld.param.u64  %rd3, [_Z3addPiS_S_i_param_2];  // Load address of C into %rd3
    ld.param.u32  %r2, [_Z3addPiS_S_i_param_3];   // Load value of n into %r2

    // Compute thread index: index = threadIdx.x + blockIdx.x * blockDim.x
    mov.u32   %r3, %tid.x;  // Get thread index (threadIdx.x)
    mov.u32   %r4, %ntid.x; // Get block size (blockDim.x)
    mov.u32   %r5, %ctaid.x; // Get block index (blockIdx.x)
    mad.lo.s32 %r1, %r5, %r4, %r3; // Compute global thread index: r1 = (blockIdx.x * blockDim.x) + threadIdx.x

    // If thread index >= n, branch to return
    setp.ge.s32 %p1, %r1, %r2;  // Set predicate if (index >= n)
    @%p1 bra $L__BB0_2;         // If predicate is true, branch to exit label

    // Convert pointer A to global memory space
    cvta.to.global.u64 %rd4, %rd1; 

    // Compute memory address for A[index]: &A[index] = A + index * 4 (assuming int size = 4 bytes)
    mul.wide.s32 %rd5, %r1, 4; // Compute index offset (index * sizeof(int))
    add.s64  %rd6, %rd4, %rd5; // Compute final address of A[index]

    // Convert pointer B to global memory space
    cvta.to.global.u64 %rd7, %rd2; 
    add.s64  %rd8, %rd7, %rd5; // Compute final address of B[index]

    // Load values from A[index] and B[index]
    ld.global.u32 %r6, [%rd8]; // Load value from B[index]
    ld.global.u32 %r7, [%rd6]; // Load value from A[index]

    // Perform addition: C[index] = A[index] + B[index]
    add.s32 %r8, %r6, %r7; 

    // Convert pointer C to global memory space
    cvta.to.global.u64 %rd9, %rd3; 
    add.s64  %rd10, %rd9, %rd5; // Compute final address of C[index]

    // Store result back to global memory: C[index] = A[index] + B[index]
    st.global.u32 [%rd10], %r8;

$L__BB0_2: // Exit label
    ret; // Return from kernel

}
